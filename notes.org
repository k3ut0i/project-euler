* Some notes on my solutions
1-25 are re-done in [[file:learning-julia.org][julia]].
** DONE 26 - Reciprocal Cycles
1. I can simulate the division method and look for cycles.
2. It feels like there is a mathematical method here
   If there is are repeating part, then Sum{r*10^-xi} will be the repeating part. where r is the sequence of digits and x is the length of repeating part. This is equal to r*Sum{10^-xi} = r/(1-10^-x). There will be 10^-a factor involved, but let us ignore that for now. Thus r*10^x/(999..9). So the denominator times 99...9 must be an integer or a non-recuring fraction that doesn't interact with this recurring part.

The intuition is there, but need to put it down concretely.
I somehow worked it through with many assumptions and arrived at the correct answer.
** DONE 27 - Quadratic Primes
- for n^2+an+b to be prime from n=0, b must be a prime and, n must be below b.
- 1+a+b must also be a prime.
- ~[(a, b) for a in (-1000:1000) for b in ps if is_prime(a+b+1)]~ gives 39k elements
- I have an idea to write a winner iterator. :| Turns out to be kind of bfs search.
  - There is a sequence of values, each of which might go to next step.
  - At any step if the next step fails, we remove it.
  - finally we are left with only winners
  - so we need two functions, _next_step_, _failed?_
  - Will be useful for pruning search spaces, also for bfs traversal search if we can allow _next_step_ to give us multiple next states.

Just brute forced it, after filtering b choices to positive and primes numbers

** DONE 28 - Number Spiral Diagonals
- length of the side of squares is [1, 3, 5, ....]
- if length of side is n, then there are 4*(n-1) numbers on that square
- the starting number is (n-2)^2+1 and ending number is n^2
- thus the diagonal numbers are (n-2)^2+(n-1), (n-2)^2+2(n-1), (n-2)^2+3(n-1), (n-2)^2+4(n-1)
- The sum of these is 4(n-2)^2+10(n-1) = 4n^2-6n+6
- we can also sum these directly as Sum(n^2) and sum(n) are simple enough
  + Have to be careful on n=1, The above quadratic gives 4 as it counts 1 itself 4 times

** DONE 29 - Distinct Powers
a^b = x^y and a < x, then x and a are both powers of some common number.
- we can reduce a^b to an^bn, where an^e = a and b*e = bn and an^e <= ub, bn <= ub
  and (an, bn) is the pair with smallest _an_ among all such possible pairs.
- If a^b = x^y, then both of them will reduce to the same pair of numbers.
- Now we just have to count the number of unique pairs
:) All this just to avoid brute-forcing by BigInts. That's just a one-liner.

** DONE 30 - Digit Fifth Powers
I need to figure out the upper bound number possible.
- For a number with (k+1) digits, 10^k is the smallest possible number and digit power sum is (k+1)*9^e. Since one is exponential and one is linear, there will be an upper bound.
- For this case 10^k > (k+1)*9^5. for k=5, we have 10^5 < 6*9^5, but 10^6 > 7*9^5. So we need only consider upto k=5, i.e., 6digit numbers, i.e., numbers below one million.

- a million iterations of a simple function(5 powers, 5 sums), it will run within 1sec

** DONE 31 - Coin Sums
Change-Making Problem:: How many ways can 2 pounds(200 pences) be formed from
1p, 2p, 5p, 10p, 20p, 50p, 1P(100p), 2P(200p)
- This can be done with combinatorics.
  + I remember doing some generating functions method to do something like this.
  + with 8 different choices, this is not a good way to get answer
- until wikipedia on _change making problem_ suggested dynamic programming. I didn't even recognize this as a simple knapsack problem!
- Brute-forcing requires going through a search space of 200*100*40*20*10*4*2 = 1_280_000_000, a billion
  + we can decrease this a lot by getting a combinatorial answer to (1p, 2p). Now the search space will just be 40*20*10*4*2 = 64_000.
    #+begin_quote
julia> @timev num_partitions_with(200, [5, 10, 20, 50, 100, 200]); nothing
  0.262925 seconds (778.84 k allocations: 70.602 MiB, 76.49% gc time)
elapsed time (ns):  262924841
gc time (ns):       201122614
bytes allocated:    74031456
pool allocs:        778823
non-pool GC allocs: 11
malloc() calls:     1
realloc() calls:    2
free() calls:       2
minor collections:  0
full collections:   1
    #+end_quote
    Not a bad reduction. 10^9 search space would have taken a lot longer.


** DONE 32 - Pandigital Products
A n-digit number is pandigital if it uses all digits 1..n exactly once.
- I might've done this before in prolog.
- I need to find bounds for A, B, C such that A*B = C is a possible pandigital product.
  + suppose A has x+1 digits, B has y+1 digits and C has z+1 digits.
    x+y+z = 6
    x+y < z+1
    x+1+y+1 > z.
    So z-2 < x+y < z+1, ie., x+y can only be z or z+1
    x+y+z can only be 2z or 2z+1 = 6. So z can only be 3.
- So should I check every divisor for every 4 digit number that has non repeating digit?
#+begin_quote
julia> @timev spf = smallest_prime_factors(10_000); sum(filter(x -> is_pandigital(x, spf), 1000:9999));nothing
  0.000591 seconds (2 allocations: 78.172 KiB)
elapsed time (ns):  591016
gc time (ns):       0
bytes allocated:    80048
pool allocs:        1
non-pool GC allocs: 0
malloc() calls:     1
free() calls:       0
minor collections:  0
full collections:   0

#+end_quote
:) less than 1ms

** DONE 33 - Digit Cancelling Fractions
- multiples of 11 are trivial cases
- foldl(*, filter(is_digit_cancelling ,...))


** DONE 34 - Digit Factorials
- Need to find bounds
  + the k digit number must be smaller than (k+1)*factorial(9)
  + the k digit number must be greater than (k+1)
  + So k >= 2 and k <= 7 (smallest 8 digit number is > 9*factorial(9))
  + 2:9_999_999
- simple brute forcing worked < 2 seconds


** DONE 35 - Circular Primes
- ~NumberTheory~ is becoming quite usefull. brute-forcing worked in < 1 second
- ~circshift~ in julia :) made things easier


** DONE 36 - Double-base Palindromes

- julia has ~digits(n, base)~; nice


** DONE 37 - Truncatable Primes
- ~f(x) = x*x~ version of function definition. I didn't realize this even after writing a Base.show method previously.
- tried out the upper bound as 1 million and that gave me 11 numbers. worked on the first try :)

** DONE 38 - Pandigital Multiples
- upper bound for the integer is 9999 since atleast two of the numbers must be concatenated. If it has 5 digits, then the result will non have 9 digits in it.
- n <= 9 since anything greater than that will give result with > 9 digits in it.
- rest is brute-force search

** DONE 39 - Integer Right Triangles
x+y+z = p, (x, y, z) form a right triangle with perimeter p. Which perimeter gives the most number of right triangles? 120 gives 3 of them.
- just brute forced it. 150ms. Is there a way to do this optimally?


** DONE 40 - Champernowne's Constant
- (10-1)x1 digit numbers, (99-9)x2 digit numbers, (999-99)x3 digit numbers ...
  - 9e(a-1)xa digit numbers
- Now we figure out for each i, to which block it belongs.
- after that with (i-sum(prev_blocks))mod(digits in each number of that block) and div gives us which number and which digit of the number
Requires careful shaping of boundries.
Sighhh... that was hairy. I was lucky it worked as fast as it did.

** DONE 41 - Pandigital Prime
- Worst case scenario, a 9-digit pandigital prime exists
  + factorial(9) numbers must be checked it they are prime.
- Hmm, there are no 8 or 9-digit pandigital primes at all
  + Only 4 and 7 digit ones; curious

** DONE 42 - Triangle Coded Numbers
Feels like a AOC question.

** DONE 43 - Substring Divisibility
- cut the factorial(10) space by a factor of 10
  + d6 must be either 0 or 5
  + d4 must be even
- more optimization can be done but just this much has allowed < 1sec runtime 

** DONE 44 - Pentagon Numbers
- Pa, Pb are the pentagon numbers which give Pa+Pb=Pc and Pa-Pb=Pd;We will iterate over Pd
  + upper bound for a is (Pd-1)/3
- d is large... iterating over d is going O(n^3)
  + Iterating over a and b themselves gave me answer faster.
  + If d was small the first strategy would've given me answer faser.

** DONE 45 - Triangular, Pentagonal, Hexagonal
https://en.wikipedia.org/wiki/Polygonal_number
40755 is simultaniously all three with indices (285, 165, 143). Find the next such number
- full brute force search. < 1ms

** DONE 46 - Goldbach's Other Conjecture
- I don't see any way to optimize this :(
- 10_000 upperbound gave me the answer

** DONE 47 - Distinct Prime Factors
- again brute forcing.

** TODO 48 - Self Powers
- I'm trying to reduce this mathematically.
  + got upto a point, but I'm not sure more reduction is impossible
- I need to define modulo arithmetic for powers, mutiplication etc...
  + I'm trying to avoid BigInts

** DONE 49 - Prime Permutations
- finally had to write a choice function to get k elements from a collection
  + TODO: I should rewrite this and permutations function as iterators

** DONE 50 - Consecutive Prime Sum
- consecutive sums can be made efficient by pre-computing partial sums
- For each prime p, I need to find the bounds before checking them all
- 3secs brute-force

** DONE 51 - Prime Digit Replacements
- used ~choose~ to get choices for replacement positions
- first problem with > 5% difficulty

** DONE 52 - Permuted Multiples
- used ~Set~ for comparision


** DONE 53 - Combinatoric Selections
How many values of binomial(n, r) are greater than one-million.
- C(n, r) = C(n-1, r-1) + C(n, r-1). So if any of the summands are > 1M, then the result is also.
- We can build a 100x100 array and start building it recursively.
  + forall n. C(n, 1) = n, forall k.C(k, k) = 1.
- ~count~ is nice. I just used partial application! ~count(==(10^6), ...)~. I din't even know julia had them!!!

** TODO 54 - Poker Hands

** TODO  64 - Odd Period Square Roots
there is a recurrence relation, b/w a_i and x,y in (sqrt(N) - x)/y.
We start with x=0, y=0. When we finally end up with a same (x, y) the period will be determined.

** DONE 67 - Maximum Path Sum II
Same solution as problem 18.
